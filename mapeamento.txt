Strategy: 

public interface Entrega {
    double calcular(List<ItemPedido> itens);
}

--> Prof. Marcel: o parâmetro do método Entrega.calcular(List<ItemPedido> itens) seria mais flexível se fosse Pedido, pois poderia indagar qualquer característica necessária para calcular o valor 

ConcreteStrategy:

public class EntregaMotoboy implements Entrega{
    
     private static EntregaMotoboy entrega;
    
    private EntregaMotoboy() {}
    
    @Override
    public double calcular(List<ItemPedido> itens) {
        Integer peso = itens
                .stream()
                .map(i -> i.getProduto().getPeso())
                .reduce(Integer::sum)
                .orElse(0);

--> Prof. Marcel: cada classe de Entrega está duplicando o código para calcular o peso. Este método deveria estar em Pedido e ser chamado por quem necessita. Afinal de contas, o peso é do Pedido e calculado sobre os atributos de Pedido (itens).

        if(peso <= 25 && itens.size() <= 30)
            return 7.0;
        
        throw new TipoEntregaInvalido("O tipo de entrega escolhido não é valido");
    }
    
    public static EntregaMotoboy getInstance() {
        if (entrega == null) {
            entrega = new EntregaMotoboy();
        }
        return entrega;
    }
}

public class EntregaPAC implements Entrega{

    private static EntregaPAC entrega;
    
    private EntregaPAC() {}
    
    @Override
    public double calcular(List<ItemPedido> itens) {
        Integer peso = itens
                .stream()
                .map(i -> i.getProduto().getPeso())
                .reduce(Integer::sum)
                .orElse(0);
        
        if (peso > 1 && peso <= 2) {
            return 15.;
        } else if (peso > 2 && peso <= 3) {
            return 20.;
        } else if (peso > 3 && peso <= 5) {
            return 30.;
        } else {
            throw new TipoEntregaInvalido("Tipo de entrega inválido.");
        }
    }
    
    public static EntregaPAC getInstance() {
        if(entrega == null)
            entrega = new EntregaPAC();
        return entrega;
    }
    
}

public class EntregaSEDEX implements Entrega{
    private static EntregaSEDEX entrega;
    
    private EntregaSEDEX() {}
    
    @Override
    public double calcular(List<ItemPedido> itens) {
        Integer peso = itens
                .stream()
                .map(i -> i.getProduto().getPeso())
                .reduce(Integer::sum).orElse(0);
        
        if (peso <= .5) {
            return 12.5;
        } else if (peso <= .75) {
            return 20.;
        } else if (peso <= 1.2) {
            return 30.;
        } else {
            double valor = 45.;
            if (peso - 2 >= .1) {
                for (int i = 0; i < (peso - 2) * 100 / 10; i++) {
                    valor += 1.5;
                }
            }
            if (peso * 10 - (int) peso * 10 > 0) {
                valor += 1.5;
            }
            return valor;
        }
    }
    
    public static EntregaSEDEX getInstance() {
        if (entrega == null) {
            entrega = new EntregaSEDEX();
        }
        return entrega;
    }
}

Context: 

public class Pedido {

    private int numero;
    private String nomeCliente;
    private Date data;
    private String endereco;
    public ArrayList<ItemPedido> itens;
    
    public Pedido() {
        itens = new ArrayList();
    }

    public int getNumero() {
        return numero;
    }

    public void setNumero(int numero) {
        this.numero = numero;
    }

    public String getNomeCliente() {
        return nomeCliente;
    }

    public void setNomeCliente(String nomeCliente) {
        this.nomeCliente = nomeCliente;
    }

    public Date getData() {
        return data;
    }

    public void setData(Date data) {
        this.data = data;
    }

    public String getEndereco() {
        return endereco;
    }

    public void setEndereco(String endereco) {
        this.endereco = endereco;
    }

    public void incluirItem(Produto p, int qtd) {
        this.itens.add(new ItemPedido(p, qtd));
    }

    public double getValorPedido() {
        double valorTotal = 0;
        for (ItemPedido ip : this.itens) {
            valorTotal += (ip.getValorItem());
        }
        return valorTotal;
    }
    
    public double getValorEntrega(TipoEntrega tipo) {
        switch (tipo) {
            case SEDEX: return EntregaSEDEX.getInstance().calcular(itens);
            case MOTOBOY: return EntregaMotoboy.getInstance().calcular(itens);
            case PAC: return EntregaPAC.getInstance().calcular(itens);
            default: return 0;
        }
    }
--> Prof. Marcel: criaram uma classe para cada tipo de entrega, ou seja, cada algoritmo de cálculo do valor de entrega foi encapsulado em um objeto - Correto! Porém não utilizaram o potencial da OO para facilitar a chamada destes algoritmos, ou seja, não aplicaram corretamente o padrão Strategy.
Deveria ter criado um atributo TipoEntrega, que armazena a referência do objeto correspondente ao tipo de entrega selecionado. O método getValorEntrega não precisaria selecionar o objeto (switch), apenas faria a chamada:  entrega.calcular(itens)

--> Prof. Marcel: o Pedido não armazenou a informação de qual tipo de entrega ele terá. Apenas é passado como parâmetro no momento do cálculo e depois perdido. Tanto que no método main é obrigado a repetir o dado passado:
        System.out.println("Valor entrega: " + pedido.getValorEntrega(TipoEntrega.RETIRADA));
        System.out.println("Valor total: " + pedido.getValorTotal(TipoEntrega.RETIRADA));


    public double getValorTotal(TipoEntrega tipo) {
        return getValorPedido() + getValorEntrega(tipo);
    }

}

--> Prof. Marcel: não mapearam o padrão Singleton
--> Prof. Marcel: Nota 2,3
